name: Sync melsec_mc from monorepo to publish repo (template)

# NOTE: This workflow is a template intended to be copied to the monorepo (melsec_com_project)
# and customized there. It creates a branch in the publish repo (tyaro/melsec_com) with the
# updated `melsec_mc` crate contents and opens a PR.

on:
  push:
    paths:
      - 'crates/melsec_mc/**'
      - 'melsec_mc/**'

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout monorepo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare export directory
        run: |
          rm -rf _export
          mkdir -p _export
          # Adjust source path to your monorepo layout
          # Prefer common monorepo layout `crates/melsec_mc`, but also support
          # a repo where the crate lives at the repository root (`melsec_mc/`).
          SRC="crates/melsec_mc"
          if [ -d "melsec_mc" ]; then
            SRC="melsec_mc"
          fi

          # Final existence check: if nothing found, exit with 0 (no-op)
          if [ ! -d "$SRC" ]; then
            echo "Source crate not found at expected paths: $SRC"
            echo "Checked: crates/melsec_mc and melsec_mc"
            echo "No changes to export; exiting."
            exit 0
          fi

          echo "Using source: $SRC"
          rsync -a --delete "$SRC"/ _export/

      - name: Validate MONOREPO_TO_PUBLISH_TOKEN
        env:
          TOKEN: ${{ secrets.MONOREPO_TO_PUBLISH_TOKEN }}
          PUBLISH_REPO: ${{ secrets.PUBLISH_REPO_OVERRIDE }}
        run: |
          # If no token is provided, skip validation (the later push step also skips on empty token).
          if [ -z "${TOKEN}" ]; then
            echo "MONOREPO_TO_PUBLISH_TOKEN not set; skipping validation"
            exit 0
          fi

          # Fallback to default publish repo if the secret for override is not set.
          if [ -z "${PUBLISH_REPO}" ]; then
            PUBLISH_REPO='tyaro/melsec_mc'
          fi

          # Mask the token so it won't be accidentally exposed in logs
          echo "::add-mask::${TOKEN}"

          echo "Checking token via GitHub API (/user)..."
          user_status=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${TOKEN}" https://api.github.com/user)
          echo "user endpoint status: ${user_status}"

          echo "Checking token access to repo: ${PUBLISH_REPO}"
          repo_status=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${TOKEN}" "https://api.github.com/repos/${PUBLISH_REPO}")
          echo "repo endpoint status: ${repo_status}"

          if [ "${user_status}" -ne 200 ]; then
            echo "::error::Token /user check failed (HTTP ${user_status}). The token may be invalid or missing scopes."
            exit 1
          fi
          if [ "${repo_status}" -ne 200 ]; then
            echo "::error::Token cannot access repo ${PUBLISH_REPO} (HTTP ${repo_status}). Ensure the token's allowed repositories include this repo or use a token with `repo` scope."
            exit 1
          fi

          echo "MONOREPO_TO_PUBLISH_TOKEN validation succeeded"

      - name: Commit and push to publish repo
        env:
          # Allow overriding the publish repository with a secret named
          # PUBLISH_REPO_OVERRIDE. If that secret is empty/unset, the
          # run script will default to 'tyaro/melsec_mc'. This avoids
          # expression parsing issues and keeps the default behavior.
          PUBLISH_REPO: ${{ secrets.PUBLISH_REPO_OVERRIDE }}
          PUBLISH_BRANCH: 'sync-from-monorepo/${{ github.sha }}'
          GIT_AUTHOR_NAME: 'github-actions[bot]'
          GIT_AUTHOR_EMAIL: '41898282+github-actions[bot]@users.noreply.github.com'
          TOKEN: ${{ secrets.MONOREPO_TO_PUBLISH_TOKEN }}
        run: |
          git config --global user.name "${GIT_AUTHOR_NAME}"
          git config --global user.email "${GIT_AUTHOR_EMAIL}"

          # If TOKEN is empty, the workflow can't push to the publish repo. Skip
          # the push to avoid failures in repositories where the secret isn't set.
          if [ -z "${TOKEN}" ]; then
            echo "MONOREPO_TO_PUBLISH_TOKEN is not set; skipping push to publish repo"
            exit 0
          fi

          # If the PUBLISH_REPO env (populated from a secret) is empty,
          # fall back to the built-in default repo.
          if [ -z "${PUBLISH_REPO}" ]; then
            PUBLISH_REPO='tyaro/melsec_mc'
          fi
          echo "Using PUBLISH_REPO: ${PUBLISH_REPO}"

          git clone --depth 1 https://x-access-token:${TOKEN}@github.com/${PUBLISH_REPO}.git out
          cd out
          git checkout -b "${PUBLISH_BRANCH}" || git switch -c "${PUBLISH_BRANCH}"

          # Copy exported crate into the publish repo root (adjust if needed)
          rsync -a --delete ../_export/ ./

          # --- Diagnostic: list any workflow files copied into the publish repo ---
          echo "--- Listing .github directory (if present) ---"
          ls -la .github || true

          echo "--- Find workflow files before cleanup ---"
          find . -path './.github/workflows/*' -type f -print | tee /tmp/workflows_before || true

          echo "--- git ls-files (top 200) ---"
          git ls-files | sed -n '1,200p' || true

          if [ -s /tmp/workflows_before ]; then
            echo "Found workflow files before cleanup:"; cat /tmp/workflows_before
          else
            echo "No workflow files found before cleanup"
          fi

          # Remove any workflow files copied from the monorepo to avoid requiring the
          # `workflow` PAT scope. Publishing code changes should not attempt to create
          # or modify Actions workflows in the target repo using a PAT without that scope.
          rm -rf .github/workflows || true

          echo "--- Find workflow files after cleanup ---"
          find . -path './.github/workflows/*' -type f -print | tee /tmp/workflows_after || true
          if [ -s /tmp/workflows_after ]; then
            echo "ERROR: Workflow files still present after cleanup:"; cat /tmp/workflows_after
            echo "Aborting to avoid push that will be rejected without workflow scope on the PAT"
            exit 1
          else
            echo "No workflow files present after cleanup"
          fi

          git add -A
          if git diff --staged --quiet; then
            echo "No changes to publish repo"
            exit 0
          fi
          git commit -m "chore(sync): update melsec_mc from monorepo (${GITHUB_SHA})"

          # Debugging: print branch/ref information before pushing to help diagnose
          # intermittent "src refspec ... does not match any" errors.
          echo "--- Git debug before push ---"
          echo "Current directory: $(pwd)"
          echo "Git branch (local): $(git branch --show-current || true)"
          echo "Git HEAD: $(git rev-parse --verify --quiet HEAD || true)"
          echo "Git refs:" ; git show-ref || true
          echo "Git status:" ; git status --porcelain --branch || true

          # Ensure origin is configured to use the provided token for push.
          # Some runner environments authenticate pushes with the GITHUB_TOKEN (github-actions[bot]),
          # which may not have write access to the target repo. Set origin to use the PAT we were
          # given and then push the current HEAD into the target branch on origin using an
          # explicit refspec.
          # Push using an explicit authenticated URL to force use of the provided PAT
          # (some runner configs prefer the injected extraheader/GITHUB_TOKEN and
          # ignore origin's URL when authenticating pushes; using the full URL here
          # ensures the PAT is used).
          echo "Pushing using PAT-backed URL (origin masked)"
          # Clear any http.extraheader (set by actions/checkout/GITHUB_TOKEN) so the explicit
          # PAT in the push URL is used instead of the injected GITHUB_TOKEN header.
          # Try both local and global unset in case the runner added the extraheader at different scopes.
          git config --local --unset-all http.https://github.com/.extraheader 2>/dev/null || true
          git config --global --unset-all http.https://github.com/.extraheader 2>/dev/null || true
          git -c http.extraheader= push --set-upstream "https://x-access-token:${TOKEN}@github.com/${PUBLISH_REPO}.git" HEAD:${PUBLISH_BRANCH}

      - name: Create PR against publish repo (via REST API)
        env:
          TOKEN: ${{ secrets.MONOREPO_TO_PUBLISH_TOKEN }}
          PUBLISH_REPO: ${{ secrets.PUBLISH_REPO_OVERRIDE }}
          PUBLISH_BRANCH: 'sync-from-monorepo/${{ github.sha }}'
        run: |
          # If no token is provided, skip PR creation.
          if [ -z "${TOKEN}" ]; then
            echo "MONOREPO_TO_PUBLISH_TOKEN not set; skipping PR creation"
            exit 0
          fi

          # Fallback to default publish repo if the secret for override is not set.
          if [ -z "${PUBLISH_REPO}" ]; then
            PUBLISH_REPO='tyaro/melsec_mc'
          fi

          echo "Creating PR in repo: ${PUBLISH_REPO} from branch ${PUBLISH_BRANCH} -> main"

          PR_TITLE="chore: sync melsec_mc from monorepo"
          PR_BODY="This PR was created automatically from the monorepo by a sync workflow."

          # Determine the base branch on the publish repo (use repo's default branch if present)
          DEFAULT_BASE=$(curl -s -H "Authorization: token ${TOKEN}" "https://api.github.com/repos/${PUBLISH_REPO}" | python -c "import sys,json;print(json.load(sys.stdin).get('default_branch'))")
          if [ -z "${DEFAULT_BASE}" ] || [ "null" = "${DEFAULT_BASE}" ]; then
            DEFAULT_BASE="main"
          fi

          # Build compact JSON payload without relying on jq or heredoc (avoid YAML parsing issues)
          PR_PAYLOAD=$(printf '{"title":"%s","head":"%s","base":"%s","body":"%s"}' "${PR_TITLE}" "${PUBLISH_BRANCH}" "${DEFAULT_BASE}" "${PR_BODY}")

          # Create PR via GitHub API
          http_code=$(curl -sSL -o /tmp/pr_resp.json -w "%{http_code}" \
            -H "Authorization: token ${TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -d "${PR_PAYLOAD}" \
            "https://api.github.com/repos/${PUBLISH_REPO}/pulls")

          echo "PR create HTTP code: ${http_code}"
          if [ "${http_code}" -ne 201 ]; then
            echo "::error::Failed to create PR (HTTP ${http_code})"
            cat /tmp/pr_resp.json || true
            exit 1
          fi

          # Print the created PR URL (use python one-liner to avoid jq/heredoc)
          python -c "import json,sys; print(json.load(open('/tmp/pr_resp.json')).get('html_url'))" || true


# IMPORTANT
# - Copy this file to the monorepo (melsec_com_project) and set secret MONOREPO_TO_PUBLISH_TOKEN
#   to a PAT with repo permissions so the workflow can push branches and create PRs in the
#   publish repository (tyaro/melsec_com).
# - Adjust rsync source paths to match your monorepo layout. This template assumes the crate
#   lives at `crates/melsec_mc/` inside the monorepo.
# - Test on a fork or with a low-privilege token before enabling on the main monorepo.
